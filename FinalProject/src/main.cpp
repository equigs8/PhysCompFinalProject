#include <Arduino.h>
#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ILI9341.h>
#include <map>
#include <array>
#include <string>
#include <math.h>
#include "pokemon.h"


// ==============================================================================
// 1. PIN DEFINITIONS (ADJUST THESE FOR YOUR WIRING)
// ==============================================================================

// SPI Display Pins (Common configuration for ESP32)
#define TFT_CS   5  // Chip Select (CS)
#define TFT_DC   4  // Data/Command (DC)
#define TFT_RST -1 // Reset pin (or -1 if connected to ESP32's reset)
// The CLK (SCK) and MOSI (SDA) pins for SPI are fixed on the ESP32 (GPIO18 and GPIO23 by default).

// Input Button Pins (Assuming buttons are wired as Active-LOW: Press connects pin to GND)
#define PIN_UP     0
#define PIN_DOWN   48
#define PIN_LEFT   39
#define PIN_RIGHT  20
#define PIN_SELECT 21
#define PIN_HOME   40
#define PIN_BUTTONA 15
#define PIN_BUTTONB 2

// ==============================================================================
// 2. DISPLAY SETUP & GLOBAL VARIABLES
// ==============================================================================

Adafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC, TFT_RST);

// --- GAME STATE MANAGEMENT ---
enum GameState {
  STATE_MENU,
  STATE_TICTACTOE,
  STATE_POKEMON_BATTLER
};
GameState currentState = STATE_MENU;

// Menu Variables
int menuSelection = 0; // Index of the currently selected menu item
const char* menuItems[] = {"Tic-Tac-Toe", "Coming Soon..."};
const int numMenuItems = sizeof(menuItems) / sizeof(menuItems[0]);

// Color Definitions
#define BLACK   0x0000
#define WHITE   0xFFFF
#define RED     0xF800
#define BLUE    0x001F
#define YELLOW  0xFFE0
#define CURSOR_COLOR 0xF800 // Light green/cyan for cursor outline
#define MAIN_MENU_COLOR BLACK


// Pokemon Battle Specific Colors
#define SKY_BLUE    0x7D1F // Light blue for sky
#define GRASS_GREEN 0x5E09 // Green for field
#define PLATFORM_COL 0xDEFB // Light yellowish-green for ellipses
#define HUD_BG      0xEF7D // Light Gray for text boxes
#define HP_GREEN    0x2624 // Bright Green
#define HP_RED      0xF800


// Icon Bitmap Data (8x8 pixels, 1-bit monochrome)
// This icon is a simple 3x3 grid for Tic-Tac-Toe
const uint8_t TIC_TAC_TOE_ICON_BITS[] PROGMEM = {
 0x24, 0x24, 0xff, 0x24, 0x24, 0xff, 0x24, 0x24
};


// Tic-Tac-Toe Variables
#define BOARD_SIZE 3
#define EMPTY 0
#define PLAYER_X 1
#define PLAYER_O 2

int board[BOARD_SIZE][BOARD_SIZE];
int currentPlayer = PLAYER_X; // X starts
int gameStatus = 0; // 0: Running, 1: X Win, 2: O Win, 3: Draw
bool gameOverScreenDrawn = false;


// Cursor position (0-2) for Tic-Tac-Toe
int cursorX = 0;
int cursorY = 0;



// Forward declaration needed for handleMenuInput
void resetTicTacToe();
void ticTacToeSelected();
void pokemonBattlerSelected();
void resetPokemonBattler();

// ==============================================================================
// 3. DRAWING FUNCTIONS
// ==============================================================================

/**
 * @brief Displays game status messages at the bottom of the screen.
 */
void displayStatus(const char* message, uint16_t color) {
  const int statusY = 220;
  tft.setTextSize(2);
  tft.setTextColor(color, BLACK);
  // Clear previous message area
  tft.fillRect(10, statusY, tft.width() - 20, 30, BLACK);
  tft.setCursor(10, statusY);
  tft.print(message);
}

/**
 * @brief Draws a simple icon next to a menu item using bitmaps or simple shapes.
 * @param itemIndex The index of the menu item (0 for Tic-Tac-Toe).
 * @param xPos The horizontal position to start drawing the icon.
 * @param yPos The vertical position (top edge) to start drawing the icon.
 * @param color The color to draw the icon.
 */
void drawMenuItemIcon(int itemIndex, int xPos, int yPos, uint16_t color) {
  int iconSize = 8;
  
  // Clear the icon area before drawing the icon to prevent color artifacts
  tft.fillRect(xPos + 3, yPos + 3, iconSize, iconSize, BLACK); 
  
  if (itemIndex == 0) {
    // Icon for Tic-Tac-Toe: Draw a 16x16 Bitmap
    // x, y, bitmap array, width, height, color
    tft.drawBitmap(xPos + 7, yPos + 7, TIC_TAC_TOE_ICON_BITS, iconSize, iconSize, RED);
    
  } else if (itemIndex == 1) {
    // Icon for "Coming Soon...": Placeholder box with '?'
    tft.drawRect(xPos + 3, yPos + 3, iconSize + 2, iconSize + 2, color);
    tft.setCursor(xPos + 5, yPos + 5);
    tft.setTextSize(1);
    tft.setTextColor(color);
    tft.print("?");
    tft.setTextSize(2); // Reset text size
  }
}


/**
 * @brief Draws the initial main menu screen.
 */
void drawMenu() {
  tft.fillScreen(MAIN_MENU_COLOR);
  tft.setTextSize(3);
  tft.setTextColor(WHITE);
  tft.setCursor(50, 20);
  tft.print("HANDHELD MENU");

  tft.setTextSize(2);
  for (int i = 0; i < numMenuItems; i++) {
    int yPos = 80 + i * 40;

    // Draw Icon
    drawMenuItemIcon(i, 15, yPos, WHITE);

    // Draw Text
    tft.setCursor(50, 80 + i * 40);
    tft.setTextColor(WHITE);
    tft.print(menuItems[i]);
  }
}

/**
 * @brief Draws or moves the cursor/selection highlight on the menu.
 */
void drawMenuCursor(int prevSelection, int newSelection) {
  int xPos = 40;
  int yStart = 80;
  int height = 20;
  int width = tft.width() - 80;

  // 1. Erase previous cursor and redraw text/icon to un-highlight (WHITE).
  if (prevSelection >= 0 && prevSelection < numMenuItems) {
    int prevYPos = yStart + prevSelection * 40;
    
    // Erase the background highlight
    tft.fillRect(xPos, prevYPos, width, height, BLACK);
    
    // Redraw Text (WHITE)
    tft.setCursor(50, prevYPos);
    tft.setTextColor(WHITE);
    tft.setTextSize(2);
    tft.print(menuItems[prevSelection]);
    
    // Redraw Icon (WHITE) (Icon position: x=5, centered vertically around text line)
    drawMenuItemIcon(prevSelection, 15, prevYPos, WHITE);
  }

  // 2. Draw new cursor highlight and redraw text/icon in BLACK.
  int newYPos = yStart + newSelection * 40;
  
  // Draw new cursor (filled box)
  tft.fillRect(xPos, newYPos, width, height, CURSOR_COLOR);
  
  // Redraw Text (BLACK on the colored cursor)
  tft.setCursor(50, newYPos);
  tft.setTextColor(BLACK); 
  tft.setTextSize(2);
  tft.print(menuItems[newSelection]);
  
  // Redraw Icon (BLACK on the colored cursor)
  drawMenuItemIcon(newSelection, 15, newYPos, WHITE);
}

// ==============================================================================
// 3.1 GENERAL INPUT HANDLER
// ==============================================================================
/**
 * @brief Handles input for all game states. Will be used for volume, home, and rest buttons.
 */

void handleGeneralInput() {
  static unsigned long lastMoveTime = 0;
  const unsigned long moveDelay = 200;
  unsigned long currentTime = millis();
  
  // Handle Home Button

  if(digitalRead(PIN_HOME) == LOW) {
    currentState = STATE_MENU;
    drawMenu();
    drawMenuCursor(-1, menuSelection); // Draw cursor at current selection
    delay(300); // Debounce
  }
  // Handle Reset. Pushing both Home and Select will reset the divice
  //TODO: Add reset action.
  // if(digitalRead(PIN_HOME) == LOW && digitalRead(PIN_SELECT) == LOW) {
  // }

}



// ==============================================================================
// 4. MENU HANDLER
// ==============================================================================

/**
 * @brief Handles input when the device is in the main menu state.
 */
void handleMenuInput() {
  static unsigned long lastMoveTime = 0;
  const unsigned long moveDelay = 200;
  unsigned long currentTime = millis();
  int prevSelection = menuSelection;

  // Handle Movement (Directional Buttons)
  if (currentTime - lastMoveTime >= moveDelay) {
    bool moved = false;

    if (digitalRead(PIN_UP) == LOW) {
      menuSelection = max(0, menuSelection - 1);
      moved = true;
    } else if (digitalRead(PIN_DOWN) == LOW) {
      menuSelection = min(numMenuItems - 1, menuSelection + 1);
      moved = true;
    }

    if (moved) {
      lastMoveTime = currentTime;
      drawMenuCursor(prevSelection, menuSelection);
    }
  }

  // Handle Action (A Button)
  if (digitalRead(PIN_BUTTONA) == LOW) {
    if (menuSelection == 0) {
      // Option 0: Tic-Tac-Toe
      ticTacToeSelected();
    } else if (menuSelection == 1) {
      // Option 1: POKEMON BATTLER
      pokemonBattlerSelected();
    }else {
      // Placeholder for other games
      displayStatus("Game unavailable", RED);
    }
    delay(300); // Debounce select press
  }
}

void ticTacToeSelected()
{
  currentState = STATE_TICTACTOE;
  resetTicTacToe();
}
void pokemonBattlerSelected(){
  currentState = STATE_POKEMON_BATTLER;
  resetPokemonBattler();
}
// ==============================================================================
// 5. TICTACTOE GAME LOGIC
// ==============================================================================

// --- Tic-Tac-Toe Drawing Functions ---

/**
 * @brief Draws the initial board and title.
 */
void drawBoard() {
  tft.fillScreen(BLACK);

  // Board dimensions setup
  int startX = 20;
  int startY = 50;
  int cellSize = 60;
  int boardDim = cellSize * BOARD_SIZE;

  // Draw grid lines
  for (int i = 1; i < BOARD_SIZE; i++) {
    // Vertical lines
    tft.fillRect(startX + i * cellSize - 1, startY, 3, boardDim, WHITE);
    // Horizontal lines
    tft.fillRect(startX, startY + i * cellSize - 1, boardDim, 3, WHITE);
  }

  // Draw Title
  tft.setFont();
  tft.setTextSize(2);
  tft.setTextColor(WHITE);
  tft.setCursor(30, 10);
  tft.print("Tic-Tac-Toe Handheld");
}

/**
 * @brief Draws X or O marker in a cell.
 */
void drawMarker(int col, int row, int player) {
  int startX = 20;
  int startY = 50;
  int cellSize = 60;
  int centerX = startX + col * cellSize + cellSize / 2;
  int centerY = startY + row * cellSize + cellSize / 2;
  int size = cellSize / 3;

  if (player == PLAYER_X) {
    tft.drawLine(centerX - size, centerY - size, centerX + size, centerY + size, RED);
    tft.drawLine(centerX - size, centerY + size, centerX + size, centerY - size, RED);
    tft.drawLine(centerX - size + 1, centerY - size, centerX + size + 1, centerY + size, RED);
    tft.drawLine(centerX - size + 1, centerY + size, centerX + size + 1, centerY - size, RED);
  } else if (player == PLAYER_O) {
    tft.drawCircle(centerX, centerY, size, BLUE);
    tft.drawCircle(centerX, centerY, size + 1, BLUE);
  }
}

/**
 * @brief Draws or erases the cursor outline around the current cell.
 */
void drawCursor(int prevX, int prevY, int newX, int newY) {
  int startX = 20;
  int startY = 50;
  int cellSize = 60;
  int margin = 5;

  // 1. Erase previous cursor position
  tft.drawRect(startX + prevX * cellSize + margin,
               startY + prevY * cellSize + margin,
               cellSize - 2 * margin, cellSize - 2 * margin, BLACK);


  // // 2. Draw new cursor position only if the game is running AND the spot is empty
  // if (gameStatus == 0 && board[newX][newY] == EMPTY) {
  //   tft.drawRect(startX + newX * cellSize + margin,
  //                startY + newY * cellSize + margin,
  //                cellSize - 2 * margin, cellSize - 2 * margin, CURSOR_COLOR);
  // }
  // 2. Draw new cursor position only if the game is running
  if (gameStatus == 0) {
    tft.drawRect(startX + newX * cellSize + margin,
                 startY + newY * cellSize + margin,
                 cellSize - 2 * margin, cellSize - 2 * margin, CURSOR_COLOR);
  }
}

// --- Tic-Tac-Toe Game Logic Functions ---

/**
 * @brief Resets the board, state, and redraws the display for a new game.
 */
void resetTicTacToe() {
  for (int i = 0; i < BOARD_SIZE; i++) {
    for (int j = 0; j < BOARD_SIZE; j++) {
      board[i][j] = EMPTY;
    }
  }
  currentPlayer = PLAYER_X;
  gameStatus = 0;
  cursorX = 0;
  cursorY = 0;
  gameOverScreenDrawn = false;

  drawBoard();
  drawCursor(0, 0, 0, 0); // Draw initial cursor at 0,0
  displayStatus("X's Turn", YELLOW);
}

/**
 * @brief Checks if the given player has won.
 * @return True if the player has won, false otherwise.
 */
bool checkWin(int player) {
  // Check rows and columns
  for (int i = 0; i < BOARD_SIZE; i++) {
    if ((board[i][0] == player && board[i][1] == player && board[i][2] == player) || // Check row i
        (board[0][i] == player && board[1][i] == player && board[2][i] == player)) { // Check col i
      return true;
    }
  }

  // Check diagonals
  if ((board[0][0] == player && board[1][1] == player && board[2][2] == player) ||
      (board[0][2] == player && board[1][1] == player && board[2][0] == player)) {
    return true;
  }

  return false;
}

/**
 * @brief Checks if the game has ended in a draw.
 * @return True if all spots are filled, false otherwise.
 */
bool checkDraw() {
  for (int i = 0; i < BOARD_SIZE; i++) {
    for (int j = 0; j < BOARD_SIZE; j++) {
      if (board[i][j] == EMPTY) {
        return false;
      }
    }
  }
  return true;
}

/**
 * @brief Handles the game over state for Tic-Tac-Toe.
 * @param winner The player who won (1 for X, 2 for O, 3 for draw).
 */
void ticTacToeGameOver(int winner) {
  if(!gameOverScreenDrawn){
    tft.fillScreen(BLACK); // Clear the screen

    tft.setFont();
    tft.setTextSize(2);
    tft.setTextColor(WHITE);
    tft.setCursor(30, 10);
    tft.print("Game Over!");

    if (winner == 1) {
      tft.setTextColor(RED);
      tft.setCursor(30, 50);
      tft.print("X Wins!");
    } else if (winner == 2) {
      tft.setTextColor(BLUE);
      tft.setCursor(30, 50);
      tft.print("O Wins!");
    }else if (winner == 3) {
      tft.setTextColor(YELLOW);
      tft.setCursor(30, 50);
      tft.print("Draw!");
    }else{
      displayStatus("ERROR! (Select to Reset)", YELLOW);
    }

    tft.setTextSize(2);
    tft.setTextColor(WHITE);
    tft.setCursor(30, 100);
    tft.print("Press Select to Reset");
    tft.setCursor(30, 130);
    tft.print("Press Menu to Exit");

    gameOverScreenDrawn = true;

  }
  if(digitalRead(PIN_SELECT) == LOW) {
      resetTicTacToe();
      delay(300);
  }
  
}

/**
 * @brief Reads physical button inputs and updates the Tic-Tac-Toe game state.
 */
void handleTicTacToeInput() {
  static unsigned long lastMoveTime = 0;
  const unsigned long moveDelay = 150; // Throttle delay for cursor movement

  // If the game is over, only the SELECT button can restart it.
  if (gameStatus != 0) {
    ticTacToeGameOver(gameStatus);
    return;
  }

  int prevX = cursorX;
  int prevY = cursorY;
  unsigned long currentTime = millis();

  // Handle Movement (Directional Buttons)
  if (currentTime - lastMoveTime >= moveDelay) {
    bool moved = false;

    if (digitalRead(PIN_UP) == LOW) {
      cursorY = max(0, cursorY - 1);
      moved = true;
    } else if (digitalRead(PIN_DOWN) == LOW) {
      cursorY = min(BOARD_SIZE - 1, cursorY + 1);
      moved = true;
    } else if (digitalRead(PIN_RIGHT) == LOW) { 
      cursorX = min(BOARD_SIZE - 1, cursorX + 1);
      moved = true;
    }else if (digitalRead(PIN_LEFT) == LOW) { 
      cursorX = max(0, cursorX - 1);
      moved = true;
    }

    if (moved) {
      lastMoveTime = currentTime;
      drawCursor(prevX, prevY, cursorX, cursorY);
      return;
    }
  }

  // Handle Action (A Button)
  if (digitalRead(PIN_BUTTONA) == LOW) {
    // Only place a marker if the current cell is empty
    if (board[cursorX][cursorY] == EMPTY) {
      // 1. Place marker
      board[cursorX][cursorY] = currentPlayer;
      drawMarker(cursorX, cursorY, currentPlayer);
      //drawCursor(cursorX, cursorY, cursorX, cursorY); // This call erases the cursor

      // 2. Check game status
      if (checkWin(currentPlayer)) {
        gameStatus = currentPlayer;
        if (currentPlayer == PLAYER_X) {
          displayStatus("X WINS! (Select to Reset)", RED);
        } else {
          displayStatus("O WINS! (Select to Reset)", BLUE);
        }
      } else if (checkDraw()) {
        gameStatus = 3;
        displayStatus("DRAW! (Select to Reset)", YELLOW);
      } else {
        // 3. Switch turn
        currentPlayer = (currentPlayer == PLAYER_X) ? PLAYER_O : PLAYER_X;
        if (currentPlayer == PLAYER_X) {
          displayStatus("X's Turn", YELLOW);
        } else {
          displayStatus("O's Turn", YELLOW);
        }
      }

      // Debounce the select press
      delay(300);
    }
  }
}

// ==============================================================================
// 5.1 POKEMON BATTLER GAME (NON-BLOCKING)
// ==============================================================================

// Sprites
const unsigned char pokemonSprite1 [] PROGMEM = {
	// 'Pokemon1, 16x16px
	0x00, 0x00, 0x60, 0x38, 0x70, 0x60, 0x6f, 0xc0, 0x49, 0xc0, 0x5b, 0xc0, 0x3c, 0x80, 0x39, 0xf0, 
	0x4f, 0x80, 0x3f, 0xc6, 0x00, 0x0c, 0x00, 0x64, 0x03, 0xf0, 0x01, 0x30, 0x05, 0x60, 0x00, 0x00
};

// 'Pokemon2', 56x56px
const unsigned char pokemonSprite2 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x0b, 0x80, 0x00, 0x00, 0x39, 0x00, 0x00, 
	0x13, 0x80, 0x00, 0x00, 0xe1, 0x00, 0x00, 0x03, 0x80, 0x00, 0x03, 0xc1, 0x00, 0x00, 0x23, 0xc0, 
	0x00, 0x0f, 0x81, 0x00, 0x00, 0x23, 0xc0, 0x00, 0x3f, 0x01, 0x00, 0x00, 0x03, 0x80, 0x00, 0x7e, 
	0x01, 0x00, 0x00, 0x43, 0x87, 0xf1, 0xfc, 0x01, 0x00, 0x00, 0x43, 0x3f, 0xfb, 0xf8, 0x01, 0x00, 
	0x00, 0x42, 0xff, 0xf7, 0xf8, 0x00, 0x00, 0x00, 0x41, 0xff, 0xff, 0xf0, 0x02, 0x00, 0x00, 0x03, 
	0xff, 0xff, 0xf0, 0x02, 0x00, 0x00, 0x07, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x03, 0xe0, 0xff, 
	0xe0, 0x04, 0x00, 0x00, 0x03, 0xe0, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x13, 0xe1, 0xff, 0xc0, 0x00, 
	0x00, 0x00, 0x17, 0xe3, 0x01, 0xc0, 0x00, 0x00, 0x00, 0x0f, 0xfc, 0x00, 0xe0, 0x00, 0x00, 0x00, 
	0x0f, 0xf8, 0x00, 0x78, 0x00, 0x00, 0x00, 0x3f, 0xf3, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x41, 0xff, 
	0xff, 0xfc, 0x00, 0x00, 0x00, 0x41, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x63, 0xff, 0xff, 0x40, 
	0x00, 0x00, 0x03, 0x37, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x0f, 0xab, 0xff, 0xff, 0x3f, 0xe0, 0x00, 
	0x00, 0x2d, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xf9, 0xf0, 0x00, 0x00, 0x01, 0xef, 
	0xff, 0xf0, 0x78, 0x0c, 0x80, 0x03, 0x07, 0xff, 0xe8, 0x1c, 0x1b, 0x80, 0x04, 0x01, 0xff, 0xf0, 
	0x06, 0x7f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbf, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x10, 0x02, 0x00, 0x06, 0x00, 0x00, 0x00, 0x14, 
	0x2f, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x14, 0x00, 0x00, 0x00, 0x6c, 0x3f, 0x80, 
	0x00, 0x00, 0x00, 0x00, 0x54, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x6c, 0xff, 0x20, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf6, 0x60, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xf0, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 
	0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 'Pokemon3_1', 56x56px
const unsigned char pokemonSprite3_1 [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x03, 0x80, 
	0x00, 0x00, 0x00, 0x01, 0xe0, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0xf0, 0x00, 0x00, 
	0x00, 0x1e, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0xf8, 
	0x00, 0x20, 0x3e, 0x00, 0x00, 0x01, 0xf2, 0x00, 0x20, 0x1f, 0x00, 0x00, 0x03, 0xe6, 0x00, 0x60, 
	0x1f, 0x80, 0x00, 0x07, 0xc4, 0x00, 0x60, 0x0f, 0xc0, 0x00, 0x0f, 0x8c, 0x00, 0xe0, 0x0f, 0xc0, 
	0x00, 0x1f, 0x0c, 0x01, 0xc0, 0x07, 0xe0, 0x00, 0x3e, 0x0c, 0x03, 0xc2, 0x07, 0xe0, 0x00, 0x7c, 
	0x0f, 0x7f, 0x8c, 0x03, 0xf0, 0x00, 0xfc, 0x0e, 0xff, 0x0c, 0x03, 0xf0, 0x01, 0xf8, 0x0f, 0xfe, 
	0x00, 0x13, 0xf8, 0x03, 0xe0, 0x0f, 0xfc, 0x00, 0x23, 0xf8, 0x07, 0xc0, 0x07, 0xf0, 0x10, 0xc3, 
	0xf8, 0x07, 0x80, 0x03, 0xe0, 0x0f, 0x03, 0xfc, 0x0f, 0x60, 0x0a, 0xc9, 0x00, 0x03, 0xfc, 0x0e, 
	0xe0, 0x02, 0xc0, 0x00, 0x03, 0xfc, 0x1c, 0xe0, 0x02, 0xc2, 0x00, 0x01, 0xfc, 0x1c, 0xc0, 0x06, 
	0xdc, 0x00, 0x01, 0xfc, 0x38, 0x00, 0x02, 0xe8, 0x00, 0x31, 0xfc, 0x38, 0x00, 0x00, 0x00, 0x80, 
	0x71, 0xfc, 0x38, 0x00, 0x00, 0x08, 0xc0, 0x71, 0xfc, 0x74, 0x00, 0x00, 0x04, 0x40, 0x61, 0xfc, 
	0x75, 0xc0, 0x00, 0x03, 0x80, 0x61, 0xfc, 0x75, 0x98, 0x0f, 0x03, 0xfc, 0x01, 0xfc, 0x72, 0xb0, 
	0x1e, 0x80, 0x04, 0x01, 0xfc, 0x78, 0x00, 0x00, 0x03, 0xf0, 0x01, 0xfc, 0x70, 0x00, 0x00, 0x03, 
	0xfc, 0x01, 0xfc, 0x70, 0x00, 0x00, 0x03, 0xfc, 0x03, 0xfc, 0x70, 0x00, 0x00, 0x03, 0xf8, 0x03, 
	0xfc, 0x70, 0x00, 0x20, 0x01, 0xf5, 0x73, 0xdc, 0x30, 0x00, 0x18, 0x00, 0x05, 0x76, 0xb8, 0x10, 
	0x00, 0x18, 0x00, 0x00, 0xb1, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x6f, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const uint16_t pokemonSprite3[56 * 56] PROGMEM = {
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0xca31, 0x0000, 0x0000, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xbef7, 0xca31, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0xca31, 0x0000, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xbef7, 0xca31, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xbef7, 0xeb8e, 0xeb8e, 0xbef7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xbef7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
  0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0xca31, 0xeb8e, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbef7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbef7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0x0000, 0x0000, 0xca31, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xca31, 
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbef7, 0xbef7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0x0000, 0x0000, 0xca31, 0xbef7, 0xbef7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xbef7, 0xeb8e, 0xca31, 
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbef7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xbef7, 0xbef7, 0xbef7, 0xeb8e, 0xca31, 0x0000, 0x0000, 0xca31, 0x524c, 0xeb8e, 0x524c, 0x524c, 0xca31, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 
  0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbef7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0xbef7, 0xeb8e, 0xeb8e, 0xeb8e, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbef7, 0xbef7, 0xeb8e, 0xca31, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 
  0x524c, 0x524c, 0xca31, 0xca31, 0xca31, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbef7, 0xbef7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0x0000, 0x0000, 0xca31, 0xca31, 0x524c, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbef7, 0xeb8e, 0xeb8e, 0xca31, 0x0000, 0x0000, 
  0xca31, 0x524c, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbef7, 0xbef7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0xca31, 0x0000, 0x0000, 0xca31, 0x524c, 0x524c, 0xca31, 0xeb8e, 0xbef7, 0xbef7, 0xeb8e, 0xbef7, 0xbef7, 0xbef7, 0xbef7, 0xeb8e, 
  0xeb8e, 0xeb8e, 0xca31, 0xca31, 0x0000, 0x0000, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xeb8e, 0xca31, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbef7, 0xbef7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0xca31, 0x524c, 0x524c, 0xca31, 0xeb8e, 0xbef7, 0xbef7, 0xeb8e, 0xbef7, 0xbef7, 0xbef7, 0xbef7, 
  0xeb8e, 0xeb8e, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xeb8e, 0xca31, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbef7, 0xbef7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xbef7, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0xca31, 0xca31, 0x524c, 0xca31, 0xca31, 0xbef7, 0xbef7, 0xeb8e, 0xbef7, 
  0xbef7, 0xbef7, 0xbef7, 0x524c, 0xca31, 0xca31, 0xca31, 0xca31, 0x524c, 0xca31, 0xeb8e, 0x524c, 0x524c, 0x524c, 0x524c, 0xeb8e, 0xeb8e, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbef7, 0xbef7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0xca31, 0xca31, 0x524c, 0xca31, 0x524c, 
  0xca31, 0xbe, 0xf7, 0xeb8e, 0xbef7, 0xbef7, 0xbef7, 0xca31, 0xca31, 0xca31, 0xca31, 0x524c, 0xca31, 0x524c, 0xca31, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xbe, 0xf7, 0xeb8e, 0xeb8e, 0xeb8e, 0x524c, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0x0000, 
  0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0xbe, 0xf7, 0xca31, 0xeb8e, 0x524c, 0xeb8e, 0xeb8e, 0xca31, 0x524c, 0xbe, 0xf7, 0x524c, 0xca31, 0xeb8e, 0xca31, 0x524c, 0x524c, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 
  0x524c, 0x524c, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0x524c, 0xca31, 0xeb8e, 0x524c, 0xeb8e, 0xeb8e, 0xca31, 0xca31, 0x524c, 0xca31, 0x524c, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0x524c, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xbe, 0xf7, 0xeb8e, 0xeb8e, 0xca31, 
  0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0xeb8e, 0x524c, 0xeb8e, 0xeb8e, 0xca31, 0xca31, 0xca31, 0x524c, 0xeb8e, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0x0000, 0x0000, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0x0000, 0x0000, 
  0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0x524c, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0x524c, 0xeb8e, 0xeb8e, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xeb8e, 0xca31, 0x0000, 0x0000, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xeb8e, 0xeb8e, 
  0xeb8e, 0xeb8e, 0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xbe, 0xf7, 0xeb8e, 0xeb8e, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0x524c, 0xeb8e, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0xca31, 
  0x524c, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xbe, 0xf7, 0xeb8e, 0xeb8e, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0x524c, 0x524c, 0x524c, 0xeb8e, 0x524c, 0x524c, 
  0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0x524c, 0xca31, 0xca31, 0xeb8e, 0xeb8e, 0x524c, 
  0x524c, 0x524c, 0x524c, 0xca31, 0xca31, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0xca31, 0xbe, 0xf7, 0xeb8e, 0xeb8e, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0xca31, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 
  0xca31, 0xca31, 0xca31, 0xca31, 0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0xca31, 0x524c, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0xca31, 0xbe, 0xf7, 0xeb8e, 0xeb8e, 0xca31, 0xbe, 0xf7, 0xca31, 0xca31, 0xca31, 0xca31, 0x524c, 0x524c, 0x524c, 0xca31, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xca31, 0x524c, 0xca31, 0xeb8e, 0x524c, 0x524c, 0xca31, 0xca31, 0x524c, 0xca31, 0x524c, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 0x524c, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0xca31, 0xbe, 0xf7, 0xeb8e, 0xeb8e, 0xca31, 0xbe, 0xf7, 0xca31, 
  0xbe, 0xf7, 0xbe, 0xf7, 0xbe, 0xf7, 0xca31, 0xca31, 0xca31, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0xca31, 0xca31, 0xca31, 0x524c, 0x524c, 0xca31, 0x524c, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 0x524c, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbe, 0xf7, 0xbe, 
  0xf7, 0xca31, 0x0000, 0x0000, 0xca31, 0xbe, 0xf7, 0xeb8e, 0xeb8e, 0xca31, 0xbe, 0xf7, 0xca31, 0xbe, 0xf7, 0xbe, 0xf7, 0x524c, 0xca31, 0xbe, 0xf7, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0xca31, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 0xca31, 0xca31, 0xca31, 0xca31, 0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 
  0x524c, 0x524c, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0xca31, 0xbe, 0xf7, 0xeb8e, 0xeb8e, 0xca31, 0xca31, 0xeb8e, 0xca31, 0xeb8e, 0xca31, 0xeb8e, 0xeb8e, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0x524c, 0xeb8e, 0x524c, 0x524c, 0x524c, 0xca31, 0xca31, 0xca31, 0x524c, 0x524c, 0xca31, 0xca31, 0xca31, 0xca31, 0xeb8e, 0xca31, 
  0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0xca31, 0xbe, 0xf7, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 
  0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xeb8e, 0xeb8e, 0xeb8e, 0x524c, 0xca31, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0xca31, 0xbe, 0xf7, 0xeb8e, 0xeb8e, 0x524c, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 
  0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0xca31, 0xca31, 0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 
  0x524c, 0x524c, 0x524c, 0x524c, 0xca31, 0xca31, 0xca31, 0xca31, 0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xca31, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0x524c, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0x524c, 0xeb8e, 0xeb8e, 0x524c, 
  0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xbe, 0xf7, 0xca31, 0xbe, 0xf7, 0x524c, 0xbe, 0xf7, 0xbe, 0xf7, 0xeb8e, 0xca31, 0xeb8e, 0xeb8e, 0x524c, 0xeb8e, 0x524c, 0xeb8e, 0xbe, 0xf7, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xbe, 0xf7, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xeb8e, 0xeb8e, 0x524c, 0x524c, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0x524c, 0x524c, 0x524c, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0x524c, 0xca31, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0xca31, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
};

// Pokemon
Move pikachuMoveset[4] = {Move(10, "Punch", 10), Move(20, "Kick", 10), Move(30, "Flash", 10), Move(40, "Bolt", 10)};
Pokemon playerPokemon = Pokemon("Pikachu", 100, 10, pikachuMoveset);

Move charmanderMoveset[4] = {Move(10, "Punch", 10), Move(20, "Kick", 10), Move(30, "Super Kick", 10), Move(40, "Hyper Kick", 10)};
Pokemon enemyPokemon = Pokemon("Charmander", 100, 10, charmanderMoveset);


//Player Bag
std::string playerBag[4] = {"Poke Ball", "Great Ball", "Ultra Ball", "Master Ball"};


// Pokemon Menu Layout Variables
int pokemonMenuRow1StartingX = 10;
int pokemonMenuRow1StartingY = 200;
int pokemonMenuRow2StartingX = 10;
int pokemonMenuRow2StartingY = 220;

// Define game state variables
bool isPlayersTurn = true;

int pokemonMenuSelection = 0; 
int pokemonSubMenuSelection = 0; 
int previousPokemonSubMenuSelection = -1;

// Visual Feedback State Variables (For the non-blocking flash effect)
bool feedbackActive = false;
unsigned long feedbackStartTime = 0;
const int FEEDBACK_DURATION = 100; // ms

std::string pokemonMove1 = playerPokemon.getMove(0).getName();
std::string pokemonMove2 = playerPokemon.getMove(1).getName();
std::string pokemonMove3 = playerPokemon.getMove(2).getName();
std::string pokemonMove4 = playerPokemon.getMove(3).getName();

const std::map<int, std::array<std::string, 4>> pokemonMenuItems = {
  {0, {"Move", "Switch", "Bag", "Run"}},
  {1, {pokemonMove1, pokemonMove2, pokemonMove3, pokemonMove4}}, 
  {2, {"Pikachu", "Charmander", "Squirtle", "Bulbasaur"}}, 
  {3, {"Poke Ball", "Great Ball", "Ultra Ball", "Master Ball"}}, 
  {4, {"Yes", "No", "",""}} 
};


// Game Over state variable
bool gameIsOver = false;



// Helper function to get X, Y, Width, Height based on cursor index (0-3)
void getCursorRect(int index, int &x, int &y, int &w, int &h) {
  w = 90; 
  h = 18; 

  // Column Logic
  if (index == 0 || index == 2) x = pokemonMenuRow1StartingX;
  else x = pokemonMenuRow1StartingX + 100;

  // Row Logic
  if (index == 0 || index == 1) y = pokemonMenuRow1StartingY;
  else y = pokemonMenuRow2StartingY;
}

void drawPokemonMenuCursor(int prevSelection, int newSelection) {
  int x, y, w, h;
  // 1. Erase previous cursor 
  if (prevSelection >= 0 && prevSelection <= 3) {
    getCursorRect(prevSelection, x, y, w, h);
    tft.drawRect(x - 2, y - 2, w, h, WHITE); 
  }
  // 2. Draw new cursor
  if (newSelection >= 0 && newSelection <= 3) {
    getCursorRect(newSelection, x, y, w, h);
    tft.drawRect(x - 2, y - 2, w, h, BLACK);
  }
}

void drawPokemonBattlerUI() {
  tft.fillRect(0, 190, tft.width(), tft.height() - 190, WHITE);
  
  std::string opt0 = pokemonMenuItems.at(pokemonMenuSelection).at(0);
  std::string opt1 = pokemonMenuItems.at(pokemonMenuSelection).at(1);
  std::string opt2 = pokemonMenuItems.at(pokemonMenuSelection).at(2);
  std::string opt3 = pokemonMenuItems.at(pokemonMenuSelection).at(3);

  tft.setTextSize(2);
  tft.setTextColor(BLACK);
  
  tft.setCursor(pokemonMenuRow1StartingX, pokemonMenuRow1StartingY);
  tft.print(opt0.c_str());
  tft.setCursor(pokemonMenuRow1StartingX + 100, pokemonMenuRow1StartingY);
  tft.print(opt1.c_str());
  tft.setCursor(pokemonMenuRow2StartingX, pokemonMenuRow2StartingY);
  tft.print(opt2.c_str());
  tft.setCursor(pokemonMenuRow2StartingX + 100, pokemonMenuRow2StartingY);
  tft.print(opt3.c_str());

  drawPokemonMenuCursor(-1, pokemonSubMenuSelection);
}

void handlePokemonBattlerInput() {
  // Static variables preserve their value between loop calls
  static unsigned long lastNavTime = 0;
  static unsigned long lastButtonTime = 0;
  
  const unsigned long navDelay = 200;    // Speed of cursor movement
  const unsigned long buttonDelay = 300; // Debounce for A/B buttons
  
  unsigned long currentTime = millis();

  // --- 1. HANDLE VISUAL FEEDBACK (Non-Blocking) ---
  // If feedback is active and time has expired, turn it off
  if (feedbackActive && (currentTime - feedbackStartTime >= FEEDBACK_DURATION)) {
    tft.fillRect(0, 0, 20, 20, BLACK); // Clear the indicator
    feedbackActive = false;
  }

  // --- 2. NAVIGATION INPUT ---
  if (currentTime - lastNavTime >= navDelay) {
    bool moved = false;
    previousPokemonSubMenuSelection = pokemonSubMenuSelection;

    // Grid Logic
    if (digitalRead(PIN_UP) == LOW) {
      if (pokemonSubMenuSelection >= 2) { 
        pokemonSubMenuSelection -= 2;
        moved = true;
      }
    } 
    else if (digitalRead(PIN_DOWN) == LOW) {
      if (pokemonSubMenuSelection <= 1) { 
        pokemonSubMenuSelection += 2;
        moved = true;
      }
    }
    else if (digitalRead(PIN_LEFT) == LOW) {
      if (pokemonSubMenuSelection % 2 != 0) { 
        pokemonSubMenuSelection -= 1;
        moved = true;
      }
    } 
    else if (digitalRead(PIN_RIGHT) == LOW) {
      if (pokemonSubMenuSelection % 2 == 0) { 
        pokemonSubMenuSelection += 1;
        moved = true;
      }
    }

    if (moved) {
      lastNavTime = currentTime;
      drawPokemonMenuCursor(previousPokemonSubMenuSelection, pokemonSubMenuSelection);
    }
  }

  // --- 3. BUTTON INPUTS ---
  
  // Check if enough time has passed since last button press
  if (currentTime - lastButtonTime >= buttonDelay) {
    
    // BUTTON A (Select)
    if (digitalRead(PIN_BUTTONA) == LOW) {
      lastButtonTime = currentTime; // Reset timer

      if (pokemonMenuSelection == 0) {
        // Navigate deeper
        pokemonMenuSelection = pokemonSubMenuSelection + 1;
        pokemonSubMenuSelection = 0; 
        drawPokemonBattlerUI();
      } else {
        // Perform Action (Trigger Flash Effect)
        if (!feedbackActive) {
          tft.fillRect(0, 0, 20, 20, WHITE); // Draw "On" state
          feedbackStartTime = currentTime;   // Mark start time
          feedbackActive = true;             // Set flag
        }
      }
    }

    // BUTTON B (Back)
    if (digitalRead(PIN_BUTTONB) == LOW) {
      lastButtonTime = currentTime; // Reset timer
      
      if (pokemonMenuSelection != 0) {
        pokemonMenuSelection = 0;
        pokemonSubMenuSelection = 0;
        drawPokemonBattlerUI();
      }
    }
  }
}

// --- HELPER: Draw Filled Ellipse ---
void drawFilledEllipse(int cx, int cy, int rx, int ry, uint16_t color) {
  for (int y = -ry; y <= ry; y++) {
    // Calculate the width of the ellipse at this y-level
    int width = (int)(2.0 * rx * sqrt(1.0 - ((float)(y * y) / (float)(ry * ry))));
    
    tft.drawFastHLine(cx - width / 2, cy + y, width, color);
  }
}

// --- HELPER: Draw HP Bar and Text Box ---
void drawHUD(int x, int y, const char* name, int level, int currentHP, int maxHP, bool isPlayer) {
  int w = 140;
  int h = 45;
  
  // Draw Box Background (with black outline)
  tft.fillRect(x, y, w, h, HUD_BG); // Gray background
  tft.drawRect(x, y, w, h, BLACK);  // Border
  
  // Text Settings
  tft.setTextColor(BLACK);
  tft.setTextSize(1); // Standard small font
  
  // 1. Name
  tft.setCursor(x + 10, y + 5);
  //set text size acording to name length
  if(strlen(name) > 7){
    tft.setCursor(x + 10, y + 10);
    tft.setTextSize(1);
  }else{
    tft.setTextSize(2);
  }
  
  tft.print(name);
  
  // 2. Level symbol (simple "Lv")
  tft.setTextSize(1);
  tft.setCursor(x + 100, y + 10);
  tft.print("Lv");
  tft.print(level);

  // 3. HP Bar Background
  int barX = x + 30;
  int barY = y + 25;
  int barW = 100;
  int barH = 6;
  
  tft.fillRect(barX, barY, barW, barH, 0x52AA); // Dark grey empty bar
  
  // 4. HP Bar Fill (Calculate percentage)
  float hpPercent = (float)currentHP / maxHP;
  int fillW = (int)(barW * hpPercent);
  
  // Determine color (Green > 50%, Yellow > 20%, Red otherwise)
  uint16_t hpColor = HP_GREEN;
  if(hpPercent < 0.2) hpColor = RED;
  else if(hpPercent < 0.5) hpColor = YELLOW;
  
  tft.fillRect(barX, barY, fillW, barH, hpColor);

  // 5. Numeric HP (Only for Player)
  if (isPlayer) {
    tft.setCursor(x + 50, y + 35);
    tft.print(currentHP);
    tft.print("/");
    tft.print(maxHP);
  }
}

void drawHPUI(){
  // 4. Draw Enemy HUD (Top Left)
  drawHUD(10, 15, enemyPokemon.getName(), enemyPokemon.getLevel(), enemyPokemon.getHealth(), enemyPokemon.getMaxHealth(), false);

  // 5. Draw Player HUD (Right side, above menu)
  drawHUD(170, 135, playerPokemon.getName(), playerPokemon.getLevel(), playerPokemon.getHealth(), playerPokemon.getMaxHealth(), true); // Player
}

// --- MAIN SCENE DRAW FUNCTION ---
void drawBattleScene() {
  // 1. Draw Background (Split Screen)
  // Sky (Top ~40%)
  tft.fillRect(0, 0, 320, 80, SKY_BLUE);
  // Grass (Bottom ~60% until the menu starts at 190)
  tft.fillRect(0, 80, 320, 110, GRASS_GREEN); // Ends at y=190

  // 2. Draw Enemy Platform (Top Right)
  int enemyBaseX = 230;
  int enemyBaseY = 90;
  drawFilledEllipse(enemyBaseX, enemyBaseY, 70, 25, PLATFORM_COL);
  // Outline for style
  // drawFilledEllipse(enemyBaseX, enemyBaseY, 72, 27, GRASS_GREEN); // Optional border trick

  // 3. Draw Player Platform (Bottom Left)
  int playerBaseX = 90;
  int playerBaseY = 180;
  drawFilledEllipse(playerBaseX, playerBaseY, 80, 30, PLATFORM_COL);

  drawHPUI();
  

  // 6. Draw Pokemon SpritesS
  // Enemy
  tft.drawBitmap(enemyBaseX - 30, enemyBaseY - 30, pokemonSprite3_1, 56, 56, WHITE);

  // Player
  tft.drawBitmap(playerBaseX - 30, playerBaseY - 60, pokemonSprite2, 56, 56, WHITE);
  
  //tft.drawRGBBitmap(playerBaseX - 30, playerBaseY - 60, pokemonSprite4, 56, 56);
}

void resetPokemonBattler() {
  pokemonMenuSelection = 0; 
  pokemonSubMenuSelection = 0; 
  feedbackActive = false; // Ensure feedback is reset
  tft.fillScreen(BLACK);
  //drawPokemonGFX();
  drawBattleScene();
  drawPokemonBattlerUI();
}



// ==============================================================================
// 6. ARDUINO SETUP & LOOP
// ==============================================================================

void setup() {
  Serial.begin(115200);

  // Initialize display
  tft.begin();
  // Most ILI9341 screens are 240x320. Rotation(1) makes it 320x240 (landscape)
  tft.setRotation(1);

  // Initialize buttons with internal pull-up resistors
  pinMode(PIN_UP, INPUT_PULLUP);
  pinMode(PIN_DOWN, INPUT_PULLUP);
  pinMode(PIN_LEFT, INPUT_PULLUP);
  pinMode(PIN_RIGHT, INPUT_PULLUP);
  pinMode(PIN_SELECT, INPUT_PULLUP);
  pinMode(PIN_HOME, INPUT_PULLUP);
  pinMode(PIN_BUTTONA, INPUT_PULLUP);
  pinMode(PIN_BUTTONB, INPUT_PULLUP);

  // Start the device in the main menu
  drawMenu();
  drawMenuCursor(-1, 0); // Draw cursor on the first item
}

void loop() {
  // Main state machine to switch between Menu and Game modes

  handleGeneralInput();

  switch (currentState) {
    case STATE_MENU:
      handleMenuInput();
      break;
    case STATE_TICTACTOE:
      handleTicTacToeInput();
      break;
    case STATE_POKEMON_BATTLER:
      handlePokemonBattlerInput();
      break;
  }
  //delay(10);
}